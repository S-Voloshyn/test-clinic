package com.example.clinic.service;


import com.example.clinic.entity.TaskStatus;
import com.example.clinic.entity.TreatmentPlan;
import com.example.clinic.mapper.TreatmentTaskMapper;
import com.example.clinic.repository.TreatmentPlanRepository;
import com.example.clinic.repository.TreatmentTaskRepository;
import com.example.clinic.utils.CronExpressionParserUtil;
import com.example.clinic.utils.TransactionHelper;
import lombok.AllArgsConstructor;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.stream.Collectors;

@Service
@AllArgsConstructor
public class TaskCreatorService {

    private final TreatmentPlanRepository treatmentPlanRepository;

    private final TreatmentTaskRepository taskRepository;

    private final TransactionHelper transactionHelper;

    // TODO should be called by scheduler
    // let's imagine we call the scheduler every 1 hours.
    public void processingTreatmentTasks() {

        // TODO startTime and endTime should be configurable
        // Should be discussible can be implement another way depends on ..., now we create a task an hour ahead
        // minusMinutes(1) added because in inserting the script we use now()
        var startProcessingTimeRange = LocalDateTime.now().minusMinutes(1);
        var endProcessingTimeRange = LocalDateTime.now().plusHours(1);


        var activeTreatmentPlans =
                treatmentPlanRepository.getActiveTreatmentPlans(startProcessingTimeRange, endProcessingTimeRange);

        activeTreatmentPlans
                .stream()
                .forEach(plan ->
                        transactionHelper.withTransaction(() -> {
                            createAndSaveTaskInTimeRange(plan, startProcessingTimeRange, endProcessingTimeRange);
                            updatePlan(plan);
                        }));
    }

    private void createAndSaveTaskInTimeRange(TreatmentPlan plan, LocalDateTime startTime, LocalDateTime endTime) {

        var recurrenceTimes = CronExpressionParserUtil.getLocalDateTimesFromCronBetween(startTime, endTime, plan.getRecurrence());

        var treatmentPlans = recurrenceTimes
                .stream()
                //exclude duplicates (generated by scalability for example)
                .filter(taskStartTime -> !taskRepository.existsByStartTimeAndActionTypeAndPatientIdAndStatus(taskStartTime, plan.getActionType(), plan.getPatientId(), TaskStatus.ACTIVE))
                .map(taskStartTime -> TreatmentTaskMapper.mapToTreatmentTask(plan, taskStartTime, TaskStatus.ACTIVE))
                .collect(Collectors.toList());

        taskRepository.saveAll(treatmentPlans);
    }

    private void updatePlan(TreatmentPlan plan) {
        plan.setLastProcessingTime(LocalDateTime.now());
        treatmentPlanRepository.save(plan);
    }
}
